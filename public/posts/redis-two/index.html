<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis设计与实现之「单机数据库的一些功能实现」 | Bazinga's Blog</title><meta name=keywords content="redis"><meta name=description content="Redis 单机数据库的一些功能实现"><meta name=author content="Me"><link rel=canonical href=http://chown.xyz/posts/redis-two/><link crossorigin=anonymous href=/assets/css/stylesheet.min.6cba0d81b5f3f42bb578d49f402ba4175aa72b43def148780b8ad714c957c6f5.css integrity="sha256-bLoNgbXz9Cu1eNSfQCukF1qnK0Pe8Uh4C4rXFMlXxvU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=http://chown.xyz/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://chown.xyz/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://chown.xyz/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://chown.xyz/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://chown.xyz/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.84.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="Redis设计与实现之「单机数据库的一些功能实现」"><meta property="og:description" content="Redis 单机数据库的一些功能实现"><meta property="og:type" content="article"><meta property="og:url" content="http://chown.xyz/posts/redis-two/"><meta property="og:image" content="http://chown.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-20T00:00:00+00:00"><meta property="article:modified_time" content="2021-08-20T00:00:00+00:00"><meta property="og:site_name" content="Bazinga"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://chown.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Redis设计与实现之「单机数据库的一些功能实现」"><meta name=twitter:description content="Redis 单机数据库的一些功能实现"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://chown.xyz/posts/"},{"@type":"ListItem","position":3,"name":"Redis设计与实现之「单机数据库的一些功能实现」","item":"http://chown.xyz/posts/redis-two/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis设计与实现之「单机数据库的一些功能实现」","name":"Redis设计与实现之「单机数据库的一些功能实现」","description":"Redis 单机数据库的一些功能实现","keywords":["redis"],"articleBody":"数据库系统 struct redisServer { /* General */ redisDb *db; /* 数组，保存服务器中所有数据库 */ int dbnum /* Total number of configured DBs */ /* Networking */ list *clients; /* List of active clients */ list *clients_to_close; /* Clients to close asynchronously */ client *current_client; /* Current client executing the command. */ /* time cache */ mstime_t mstime; /* 'unixtime' in milliseconds. */ ustime_t ustime; /* 'unixtime' in microseconds. */ /* RDB / AOF loading information */ /* Configuration */ /* AOF persistence */ /* Replication (master) */ /* Replication (slave) */ /* Cluster */ /* Scripting */ /* Lazy free */ /* cpu affinity */ .... } 每个数据库都是由 redis.h/redisDb 结构表示\ntypedef struct redisDb { dict *dict; /* The keyspace for this DB 键空间 */ dict *expires; /* Timeout of keys with a timeout set */ dict *blocking_keys; /* Keys with clients waiting for data (BLPOP)*/ dict *ready_keys; /* Blocked keys that received a PUSH */ dict *watched_keys; /* WATCHED keys for MULTI/EXEC CAS */ int id; /* Database ID */ long long avg_ttl; /* Average TTL, just for stats */ unsigned long expires_cursor; /* Cursor of the active expire cycle. */ list *defrag_later; /* List of key names to attempt to defrag one by one, gradually. */ } redisDb; 键空间 redisDb中的 dict 字典 保存了所有的键值对，称为键空间。\n每个键值对\n 键是一个字符串对象 值是五种基本类型对象之一  键的过期时间\n过期时间为 expires 字段，也是 dict 字典，其中保存了所有键的过期时间\n每个键值对\n 键指针，指向键空间中的对象 值过期时间(unix timestamp milliseconds)  设置过期时间命令：\n/* EXPIRE key seconds */ void expireCommand(client *c) { expireGenericCommand(c,mstime(),UNIT_SECONDS); } /* EXPIREAT key time */ void expireatCommand(client *c) { expireGenericCommand(c,0,UNIT_SECONDS); } /* PEXPIRE key milliseconds */ void pexpireCommand(client *c) { expireGenericCommand(c,mstime(),UNIT_MILLISECONDS); } /* PEXPIREAT key ms_time */ void pexpireatCommand(client *c) { expireGenericCommand(c,0,UNIT_MILLISECONDS); } // 底层都转化为 expireGenericCommand 命令 void expireGenericCommand(client *c, long long basetime, int unit) void setExpire(client *c, redisDb *db, robj *key, long long when) {} 如何过期的在后面讲→\n命令在键空间阶段的执行过程\n SET  // 入口 void setCommand(client *c) {} // 实现了 SET 、 SETEX 、 PSETEX 和 SETNX 命令。 void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {} // 高层次的 SET 操作函数 - 增加引用计数.. void genericSetKey(client *c, redisDb *db, robj *key, robj *val, int keepttl, int signal) {} // 将键值对 key 和 val 添加到数据库中，上层增加引用计数 void dbAdd(redisDb *db, robj *key, robj *val) {} // 尝试将给定键值对添加到字典中 int dictAdd(dict *d, void *key, void *val){} // 字典的插入操作 dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing){}  DEL  void delCommand(redisClient *c) {} void delGenericCommand(client *c, int lazy) {} // 从数据库中删除给定的键，键的值，以及键的过期时间。 int dbSyncDelete(redisDb *db, robj *key) {} // 从字典中删除包含给定键的节点 int dictDelete(dict *ht, const void *key) {} // 字典的删除操作 static int dictGenericDelete(dict *d, const void *key, int nofree){}  GET  void getCommand(client *c) {} int getGenericCommand(client *c) {} // 执行读取操作而从数据库中查找返回 key 的值。 robj *lookupKeyReadOrReply(client *c, robj *key, robj *reply) {} // 为执行读取操作而取出键 key 在数据库 db 中的值。 更新命中/不命中信息 robj *lookupKeyRead(redisDb *db, robj *key) {} robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) {} // 从数据库 db 中取出键 key 的值（对象） robj *lookupKey(redisDb *db, robj *key, int flags) {} // 字典的查找操作 dictEntry *dictFind(dict *d, const void *key){} 服务端 初始化服务器 void initServer(void) {}\n 初始化配置，加载、解析配置文件 初始化内部变量 事件循环 socket监听 时间事件、文件事件 启动事件循环  server.c/main(){ void initServerConfig(void) {} // 初始化配置，给配置参数赋初始值 \tvoid loadServerConfig(char *filename, char *options) {} // 从给定文件中载入服务器配置 \tvoid initServer(void) { // 真正初始化服务器内部变量，客户端链表、数据库、全局变量和共享对象等 \tcreateSharedObjects(); //初始化共享变量... \tserver.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR); // 初始化事件处理器状态... \t... server.db = zmalloc(sizeof(redisDb)*server.dbnum); // 创建数据库  /* Open the TCP listening socket for the user commands. */ // 启动监听  if (server.port != 0 \u0026\u0026 listenToPort(server.port,server.ipfd,\u0026server.ipfd_count) == C_ERR) exit(1); if (server.tls_port != 0 \u0026\u0026 listenToPort(server.tls_port,server.tlsfd,\u0026server.tlsfd_count) == C_ERR) exit(1); ... /* Create the Redis databases, and initialize other internal state. */ for (j = 0; j  server.dbnum; j++) { server.db[j].dict = dictCreate(\u0026dbDictType,NULL); server.db[j].expires = dictCreate(\u0026keyptrDictType,NULL); server.db[j].expires_cursor = 0; server.db[j].blocking_keys = dictCreate(\u0026keylistDictType,NULL); server.db[j].ready_keys = dictCreate(\u0026objectKeyPointerValueDictType,NULL); server.db[j].watched_keys = dictCreate(\u0026keylistDictType,NULL); server.db[j].id = j; server.db[j].avg_ttl = 0; server.db[j].defrag_later = listCreate(); listSetFreeMethod(server.db[j].defrag_later,(void (*)(void*))sdsfree); } ... if (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) { serverPanic(\"Can't create event loop timers.\"); exit(1); } /* Create an event handler for accepting new connections in TCP and Unix * domain sockets. */ // 对于监听的socket创建对应的文件事件。  for (j = 0; j  server.ipfd_count; j++) { if (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE, acceptTcpHandler,NULL) == AE_ERR) { serverPanic( \"Unrecoverable error creating server.ipfd file event.\"); } } ... aeMain(server.el); // 事件处理器的主循环 \t} } 命令在接收后阶段的执行过程\n  命令解析(通信协议, RESP)\n redis 协议: \\\\r\\\\n(CRLF)区分命令请求的若干参数， *n 表示n个参数, $n 表示参数字符串长度。 如 SET KEY VALUE ，转换协议后为： *3\\\\r\\\\n$3\\\\r\\\\nSET\\\\r\\\\n$3\\\\r\\\\nKEY\\\\r\\\\n$5\\\\r\\\\nVALUE\\\\r\\\\n 特点：\n  易于实现 可以高效地被计算机分析（数据的长度放在数据正文) 可以很容易地被人类读懂 (非二进制)    命令调用\n  返回结果\n  connSetReadHandler(conn, readQueryFromClient); // - 绑定命令处理器 void readQueryFromClient(connection *conn) { // 缓冲区一堆操作... \t// 从查询缓存读取内容，创建参数，并执行命令 \tvoid processInputBuffer(client *c) { ... // 判断请求类型 内联命令 和 其他普通 \t// 将缓冲区中的内容转换成命令，以及命令参数 \tint processMultibulkBuffer(redisClient *c) { // 参数协议解析 \t} // 执行命令 \tint processCommandAndResetClient(client *c) { int processCommand(client *c) { c-cmd = c-lastcmd = lookupCommand(c-argv[0]-ptr); // 查找命令，并进行命令合法性检查，以及命令参数个数检查  /* Exec the command */ if (c-flags \u0026 CLIENT_MULTI \u0026\u0026 c-cmd-proc != execCommand \u0026\u0026 c-cmd-proc != discardCommand \u0026\u0026 c-cmd-proc != multiCommand \u0026\u0026 c-cmd-proc != watchCommand) { queueMultiCommand(c); // 事务命令处理 \taddReply(c,shared.queued); } else { // 执行命令 \tvoid call(client *c, int flags) { c-cmd-proc(c); // 执行实现函数 \t} c-woff = server.master_repl_offset; if (listLength(server.ready_keys)) handleClientsBlockedOnKeys(); } } } } } 事件 Redis 是 事件驱动程序 ，有两类事件\n  文件事件\n套接字与客户端连接，Server和Client通信，产生相应的文件事件，服务器通过监听处理这些事件来完成通信操作\n  时间事件\n服务器中维护的一些操作，在给定时间点执行，抽象为时间事件。如清理过期键值对、持久化、同步等等。\n  事件的调度执行 // 事件处理器的主循环  void aeMain(aeEventLoop *eventLoop) { eventLoop-stop = 0; while (!eventLoop-stop) { // 如果有需要在事件处理前执行的函数，那么运行它  if (eventLoop-beforesleep != NULL) eventLoop-beforesleep(eventLoop); // 开始处理事件  aeProcessEvents(eventLoop, AE_ALL_EVENTS); } } // 处理所有已到达的时间事件，以及所有已就绪的文件事件。 int aeProcessEvents(aeEventLoop *eventLoop, int flags){ // 计算最快要执行的时间事件的等待时间 \taeSearchNearestTimer(eventLoop); // 阻塞等待文件事件 \taeApiPoll(eventLoop, tvp); // 处理文件事件 \tfor (j = 0; j  numevents; j++) { // 读事件  fe-rfileProc(eventLoop,fd,fe-clientData,mask); // 写事件  fe-wfileProc(eventLoop,fd,fe-clientData,mask); processed++; } // 处理时间事件 \tprocessTimeEvents(aeEventLoop *eventLoop) } 文件事件  I/O 多路复用监听套接字，根据套接字的任务不同，分配不同的任务处理器 当套接字准备好执行操作时，与操作相应的文件事件就会产生，调用关联好的事件处理器  多种文件处理器：\n 连接应答处理器 acceptTcpHandler 命令请求处理器 readQueryFromClient 命令回复处理器 sendReplyToClient  命令在文件事件阶段的执行过程\n// 客户端申请连接，socket 将产生 `AE_READABLE` 类型事件，交给连接处理器处理 aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE, acceptTcpHandler,NULL) == AE_ERR) // 客户端发送命令请求，产生一个 `AE_READABLE` 类型事件，交给命令请求处理器... aeCreateFileEvent(server.el,fd,AE_READABLE, readQueryFromClient, c) == AE_ERR // 客户端尝试读取回复，产生一个 `AE_WRITEABLE` 类型事件，交给回复处理器... 时间事件  定时事件 周期事件  serverCron 函数\n 更新服务器信息，时间、内存 过期 持久化 同步  线程模型的进化 单线程\n单线程模型的好处\n 方便维护、开发、调试 使用单线程模型也能并发的处理客户端的请求，I/O多路复用 大多数操作在内存中完成，性能瓶颈不在CPU，在于网络I/O  不仅仅单线程\nredis 在4.0 版本引入一些支持异步处理的删除命令， UNLINK FLUSHDB ASYNC …\n对于超大键值对，Redis 可能会需要在释放内存空间上消耗较多的时间，这些操作就会阻塞待处理的任务\nvoid unlinkCommand(client *c) { /* This command implements DEL and LAZYDEL. */ void delGenericCommand(client *c, int lazy) { int numdel = 0, j; for (j = 1; j  c-argc; j++) { expireIfNeeded(c-db,c-argv[j]); int deleted = lazy ? dbAsyncDelete(c-db,c-argv[j]) : dbSyncDelete(c-db,c-argv[j]); if (deleted) { signalModifiedKey(c,c-db,c-argv[j]); notifyKeyspaceEvent(NOTIFY_GENERIC, \"del\",c-argv[j],c-db-id); server.dirty++; numdel++; } } addReplyLongLong(c,numdel); } } 网络IO处理多线程\n I/O 多路复用的主要作用是让我们可以使用一个线程来监控多个连接是否可读或者可写，但是从网络另一头发的数据包需要先解序列化成 Redis 内部其他模块可以理解的命令，这个过程就是 Redis 6.0 引入多线程来并发处理的。 I/O 多路复用模块收到数据包之后将其丢给后面多个 I/O 线程进行解析，I/O 线程处理结束后，主线程会负责串行的执行这些命令，由于向客户端发回数据包的过程也是比较耗时的，所以执行之后的结果也会交给多个 I/O 线程发送回客户端。\n 实现了I/O读写的多线程，而执行命令依旧是单线程。\n// 在多线程I/O开启时，将读事件放入队列中，等待主线程将读事件分配给I/O线程 // 这里只是把读事件添加到clients_pending_read队列中而已 int postponeClientRead(client *c) {} // 执行 int handleClientsWithPendingReadsUsingThreads(void) { // 将读事件根据RR，分配给所有的I/O线程（包括主线程自己） \twhile((ln = listNext(\u0026li))) { client *c = listNodeValue(ln); int target_id = item_id % server.io_threads_num; listAddNodeTail(io_threads_list[target_id],c); item_id++; } // 主线程读取并解析客户端请求（和I/O线程一起，但不执行命令） \tlistRewind(io_threads_list[0],\u0026li); while((ln = listNext(\u0026li))) { client *c = listNodeValue(ln); // 这里对应3.1.a中postponeClientRead会返回0, 所以数据会被读取和解析  readQueryFromClient(c-conn); } // 等待I/O线程读取完毕 \twhile(1) { unsigned long pending = 0; for (int j = 1; j  server.io_threads_num; j++) pending += io_threads_pending[j]; if (pending == 0) break; } // 遍历所有的事件（通过遍历clients_pending_read上的客户端），解析和执行命令  while(listLength(server.clients_pending_read)) { ln = listFirst(server.clients_pending_read); client *c = listNodeValue(ln); c-flags \u0026= ~CLIENT_PENDING_READ; listDelNode(server.clients_pending_read,ln); if (c-flags \u0026 CLIENT_PENDING_COMMAND) { // b) 若CLIENT_PENDING_COMMAND被标记，说明有命令被解析出来  // 所以要执行命令  c-flags \u0026= ~CLIENT_PENDING_COMMAND; if (processCommandAndResetClient(c) == C_ERR) { /* If the client is no longer valid, we avoid * processing the client later. So we just go * to the next. */ continue; } } // c) 命令解析和执行  processInputBufferAndReplicate(c); } } I/O线程的任务\nvoid *IOThreadMain(void *myid) { // 轮询，判断是否有任务要做 \t// 根据任务类型（读/写），执行任务 \tlong id = (unsigned long)myid; while(1) { // 轮询，判断是否有任务过来  for (int j = 0; j  1000000; j++) { if (io_threads_pending[id] != 0) break; } // 遍历任务列表，根据任务类型，执行I/O任务  listIter li; listNode *ln; listRewind(io_threads_list[id],\u0026li); while((ln = listNext(\u0026li))) { client *c = listNodeValue(ln); if (io_threads_op == IO_THREADS_OP_WRITE) { writeToClient(c,0); // 写，返回响应  } else if (io_threads_op == IO_THREADS_OP_READ) { readQueryFromClient(c-conn); // 读, 上面提过，不会执行命令  } else { serverPanic(\"io_threads_op value is unknown\"); } } // 清空任务列表，并设置未完成任务数为0  listEmpty(io_threads_list[id]); io_threads_pending[id] = 0; // ...  } } Todo  持久化 - - 事务 - -  Reference 通信协议（protocol） - Redis 命令参考\n为什么 Redis 选择单线程模型 - 面向信仰编程\nRedis 中的事件循环 - 面向信仰编程\n","wordCount":"1260","inLanguage":"en","datePublished":"2021-08-20T00:00:00Z","dateModified":"2021-08-20T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://chown.xyz/posts/redis-two/"},"publisher":{"@type":"Organization","name":"Bazinga's Blog","logo":{"@type":"ImageObject","url":"http://chown.xyz/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=http://chown.xyz accesskey=h title="Bazinga's Blog (Alt + H)">Bazinga's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://chown.xyz/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://chown.xyz/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://chown.xyz>Home</a>&nbsp;»&nbsp;<a href=http://chown.xyz/posts/>Posts</a></div><h1 class=post-title>Redis设计与实现之「单机数据库的一些功能实现」</h1><div class=post-meta>August 20, 2021&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/redis-two.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f aria-label=数据库系统>数据库系统</a><ul><li><a href=#%e9%94%ae%e7%a9%ba%e9%97%b4 aria-label=键空间><strong>键空间</strong></a></li><li><a href=#%e6%9c%8d%e5%8a%a1%e7%ab%af aria-label=服务端>服务端</a></li></ul></li><li><a href=#%e4%ba%8b%e4%bb%b6 aria-label=事件>事件</a><ul><li><a href=#%e4%ba%8b%e4%bb%b6%e7%9a%84%e8%b0%83%e5%ba%a6%e6%89%a7%e8%a1%8c aria-label=事件的调度执行>事件的调度执行</a></li><li><a href=#%e6%96%87%e4%bb%b6%e4%ba%8b%e4%bb%b6 aria-label=文件事件>文件事件</a></li><li><a href=#%e6%97%b6%e9%97%b4%e4%ba%8b%e4%bb%b6 aria-label=时间事件>时间事件</a></li><li><a href=#%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b%e7%9a%84%e8%bf%9b%e5%8c%96 aria-label=线程模型的进化>线程模型的进化</a></li></ul></li><li><a href=#todo aria-label=Todo>Todo</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><h2 id=数据库系统>数据库系统<a hidden class=anchor aria-hidden=true href=#数据库系统>#</a></h2><p><img loading=lazy src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/36ffd043-9f7a-4efc-b417-a7ba6d6e34ca/server.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210821%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210821T163910Z&X-Amz-Expires=86400&X-Amz-Signature=7ee1fea6746db9b50d5055e6f1d859434db3b1990f29aab638e44f0d39967496&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22server.png%22" alt="server.png (5660×4460) (amazonaws.com)"></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> redisServer {
  <span style=color:#75715e>/* General */</span>
	redisDb <span style=color:#f92672>*</span>db; <span style=color:#75715e>/* 数组，保存服务器中所有数据库 */</span>
	<span style=color:#66d9ef>int</span> dbnum    <span style=color:#75715e>/* Total number of configured DBs */</span>

	<span style=color:#75715e>/* Networking */</span>
	list <span style=color:#f92672>*</span>clients;              <span style=color:#75715e>/* List of active clients */</span>
	list <span style=color:#f92672>*</span>clients_to_close;     <span style=color:#75715e>/* Clients to close asynchronously */</span>
	client <span style=color:#f92672>*</span>current_client;     <span style=color:#75715e>/* Current client executing the command. */</span>
	
	<span style=color:#75715e>/* time cache */</span>
	mstime_t mstime;            <span style=color:#75715e>/* &#39;unixtime&#39; in milliseconds. */</span>
	ustime_t ustime;            <span style=color:#75715e>/* &#39;unixtime&#39; in microseconds. */</span>
	
	<span style=color:#75715e>/* RDB / AOF loading information */</span>
	<span style=color:#75715e>/* Configuration */</span>
	<span style=color:#75715e>/* AOF persistence */</span>
	<span style=color:#75715e>/* Replication (master) */</span>
	<span style=color:#75715e>/* Replication (slave) */</span>
	<span style=color:#75715e>/* Cluster */</span>
	<span style=color:#75715e>/* Scripting */</span>
	<span style=color:#75715e>/* Lazy free */</span>
	<span style=color:#75715e>/* cpu affinity */</span>
	....
}
</code></pre></div><p>每个数据库都是由 redis.h/redisDb 结构表示</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> redisDb {
    dict <span style=color:#f92672>*</span>dict;                 <span style=color:#75715e>/* The keyspace for this DB 键空间 */</span> 
    dict <span style=color:#f92672>*</span>expires;              <span style=color:#75715e>/* Timeout of keys with a timeout set */</span>
    dict <span style=color:#f92672>*</span>blocking_keys;        <span style=color:#75715e>/* Keys with clients waiting for data (BLPOP)*/</span>
    dict <span style=color:#f92672>*</span>ready_keys;           <span style=color:#75715e>/* Blocked keys that received a PUSH */</span>
    dict <span style=color:#f92672>*</span>watched_keys;         <span style=color:#75715e>/* WATCHED keys for MULTI/EXEC CAS */</span>
    <span style=color:#66d9ef>int</span> id;                     <span style=color:#75715e>/* Database ID */</span>
    <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> avg_ttl;          <span style=color:#75715e>/* Average TTL, just for stats */</span>
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> expires_cursor; <span style=color:#75715e>/* Cursor of the active expire cycle. */</span>
    list <span style=color:#f92672>*</span>defrag_later;         <span style=color:#75715e>/* List of key names to attempt to defrag one by one, gradually. */</span>
} redisDb;
</code></pre></div><h3 id=键空间><strong>键空间</strong><a hidden class=anchor aria-hidden=true href=#键空间>#</a></h3><p>redisDb中的 <a href=https://www.notion.so/Redis-385250b9ad224a25ae7f58f20a4c6165>dict 字典</a> 保存了所有的键值对，称为键空间。</p><p>每个键值对</p><ul><li>键是一个字符串对象</li><li>值是五种基本类型对象之一</li></ul><p><strong>键的过期时间</strong></p><p>过期时间为 <code>expires</code> 字段，也是 dict 字典，其中保存了所有键的过期时间</p><p>每个键值对</p><ul><li>键指针，指向键空间中的对象</li><li>值过期时间(unix timestamp milliseconds)</li></ul><p>设置过期时间命令：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/* EXPIRE key seconds */</span>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>expireCommand</span>(client <span style=color:#f92672>*</span>c) {
    expireGenericCommand(c,mstime(),UNIT_SECONDS);
}

<span style=color:#75715e>/* EXPIREAT key time */</span>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>expireatCommand</span>(client <span style=color:#f92672>*</span>c) {
    expireGenericCommand(c,<span style=color:#ae81ff>0</span>,UNIT_SECONDS);
}

<span style=color:#75715e>/* PEXPIRE key milliseconds */</span>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pexpireCommand</span>(client <span style=color:#f92672>*</span>c) {
    expireGenericCommand(c,mstime(),UNIT_MILLISECONDS);
}

<span style=color:#75715e>/* PEXPIREAT key ms_time */</span>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pexpireatCommand</span>(client <span style=color:#f92672>*</span>c) {
    expireGenericCommand(c,<span style=color:#ae81ff>0</span>,UNIT_MILLISECONDS);
}
<span style=color:#75715e>// 底层都转化为 expireGenericCommand 命令
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>expireGenericCommand</span>(client <span style=color:#f92672>*</span>c, <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> basetime, <span style=color:#66d9ef>int</span> unit)
<span style=color:#66d9ef>void</span> setExpire(client <span style=color:#f92672>*</span>c, redisDb <span style=color:#f92672>*</span>db, robj <span style=color:#f92672>*</span>key, <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> when) {}
</code></pre></div><p>如何过期的在后面讲→</p><p><strong>命令在键空间阶段的执行过程</strong></p><ul><li>SET</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// 入口
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setCommand</span>(client <span style=color:#f92672>*</span>c) {}  
<span style=color:#75715e>// 实现了 SET 、 SETEX 、 PSETEX 和 SETNX 命令。
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setGenericCommand</span>(client <span style=color:#f92672>*</span>c, <span style=color:#66d9ef>int</span> flags, robj <span style=color:#f92672>*</span>key, robj <span style=color:#f92672>*</span>val, robj <span style=color:#f92672>*</span>expire, <span style=color:#66d9ef>int</span> unit, robj <span style=color:#f92672>*</span>ok_reply, robj <span style=color:#f92672>*</span>abort_reply) {}
<span style=color:#75715e>// 高层次的 SET 操作函数 -&gt; 增加引用计数..
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>genericSetKey</span>(client <span style=color:#f92672>*</span>c, redisDb <span style=color:#f92672>*</span>db, robj <span style=color:#f92672>*</span>key, robj <span style=color:#f92672>*</span>val, <span style=color:#66d9ef>int</span> keepttl, <span style=color:#66d9ef>int</span> signal) {}
<span style=color:#75715e>// 将键值对 key 和 val 添加到数据库中，上层增加引用计数
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dbAdd</span>(redisDb <span style=color:#f92672>*</span>db, robj <span style=color:#f92672>*</span>key, robj <span style=color:#f92672>*</span>val) {}
<span style=color:#75715e>// 尝试将给定键值对添加到字典中
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dictAdd</span>(dict <span style=color:#f92672>*</span>d, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>key, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>val){}
<span style=color:#75715e>// 字典的插入操作
</span><span style=color:#75715e></span>dictEntry <span style=color:#f92672>*</span><span style=color:#a6e22e>dictAddRaw</span>(dict <span style=color:#f92672>*</span>d, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>key, dictEntry <span style=color:#f92672>**</span>existing){}
</code></pre></div><ul><li>DEL</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>delCommand</span>(redisClient <span style=color:#f92672>*</span>c) {}
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>delGenericCommand</span>(client <span style=color:#f92672>*</span>c, <span style=color:#66d9ef>int</span> lazy) {}
<span style=color:#75715e>// 从数据库中删除给定的键，键的值，以及键的过期时间。
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dbSyncDelete</span>(redisDb <span style=color:#f92672>*</span>db, robj <span style=color:#f92672>*</span>key) {}
<span style=color:#75715e>// 从字典中删除包含给定键的节点
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dictDelete</span>(dict <span style=color:#f92672>*</span>ht, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>key) {}
<span style=color:#75715e>// 字典的删除操作
</span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dictGenericDelete</span>(dict <span style=color:#f92672>*</span>d, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>key, <span style=color:#66d9ef>int</span> nofree){}
</code></pre></div><ul><li>GET</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>getCommand</span>(client <span style=color:#f92672>*</span>c) {}
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getGenericCommand</span>(client <span style=color:#f92672>*</span>c) {}
<span style=color:#75715e>// 执行读取操作而从数据库中查找返回 key 的值。
</span><span style=color:#75715e></span>robj <span style=color:#f92672>*</span><span style=color:#a6e22e>lookupKeyReadOrReply</span>(client <span style=color:#f92672>*</span>c, robj <span style=color:#f92672>*</span>key, robj <span style=color:#f92672>*</span>reply) {}
<span style=color:#75715e>// 为执行读取操作而取出键 key 在数据库 db 中的值。 更新命中/不命中信息
</span><span style=color:#75715e></span>robj <span style=color:#f92672>*</span><span style=color:#a6e22e>lookupKeyRead</span>(redisDb <span style=color:#f92672>*</span>db, robj <span style=color:#f92672>*</span>key) {}
robj <span style=color:#f92672>*</span><span style=color:#a6e22e>lookupKeyReadWithFlags</span>(redisDb <span style=color:#f92672>*</span>db, robj <span style=color:#f92672>*</span>key, <span style=color:#66d9ef>int</span> flags) {}
<span style=color:#75715e>// 从数据库 db 中取出键 key 的值（对象）
</span><span style=color:#75715e></span>robj <span style=color:#f92672>*</span><span style=color:#a6e22e>lookupKey</span>(redisDb <span style=color:#f92672>*</span>db, robj <span style=color:#f92672>*</span>key, <span style=color:#66d9ef>int</span> flags) {}
<span style=color:#75715e>// 字典的查找操作
</span><span style=color:#75715e></span>dictEntry <span style=color:#f92672>*</span><span style=color:#a6e22e>dictFind</span>(dict <span style=color:#f92672>*</span>d, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>key){}
</code></pre></div><h3 id=服务端>服务端<a hidden class=anchor aria-hidden=true href=#服务端>#</a></h3><p><strong>初始化服务器 <code>void initServer(void) {}</code></strong></p><ul><li>初始化配置，加载、解析配置文件</li><li>初始化内部变量</li><li>事件循环</li><li>socket监听</li><li>时间事件、文件事件</li><li>启动事件循环</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>server.c<span style=color:#f92672>/</span>main(){
	<span style=color:#66d9ef>void</span> initServerConfig(<span style=color:#66d9ef>void</span>) {} <span style=color:#75715e>// 初始化配置，给配置参数赋初始值
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>void</span> loadServerConfig(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>filename, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>options) {} <span style=color:#75715e>// 从给定文件中载入服务器配置
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>void</span> initServer(<span style=color:#66d9ef>void</span>) {          <span style=color:#75715e>// 真正初始化服务器内部变量，客户端链表、数据库、全局变量和共享对象等
</span><span style=color:#75715e></span>		createSharedObjects();     <span style=color:#75715e>//初始化共享变量...
</span><span style=color:#75715e></span>		server.el <span style=color:#f92672>=</span> aeCreateEventLoop(server.maxclients<span style=color:#f92672>+</span>CONFIG_FDSET_INCR); <span style=color:#75715e>// 初始化事件处理器状态...
</span><span style=color:#75715e></span>		...
		server.db <span style=color:#f92672>=</span> zmalloc(<span style=color:#66d9ef>sizeof</span>(redisDb)<span style=color:#f92672>*</span>server.dbnum); <span style=color:#75715e>// 创建数据库
</span><span style=color:#75715e></span>
		<span style=color:#75715e>/* Open the TCP listening socket for the user commands. */</span> <span style=color:#75715e>// 启动监听
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (server.port <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span>
        listenToPort(server.port,server.ipfd,<span style=color:#f92672>&amp;</span>server.ipfd_count) <span style=color:#f92672>==</span> C_ERR)
        exit(<span style=color:#ae81ff>1</span>);
    <span style=color:#66d9ef>if</span> (server.tls_port <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span>
        listenToPort(server.tls_port,server.tlsfd,<span style=color:#f92672>&amp;</span>server.tlsfd_count) <span style=color:#f92672>==</span> C_ERR)
        exit(<span style=color:#ae81ff>1</span>);
    ...
		<span style=color:#75715e>/* Create the Redis databases, and initialize other internal state. */</span>
    <span style=color:#66d9ef>for</span> (j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> server.dbnum; j<span style=color:#f92672>++</span>) {
        server.db[j].dict <span style=color:#f92672>=</span> dictCreate(<span style=color:#f92672>&amp;</span>dbDictType,NULL);
        server.db[j].expires <span style=color:#f92672>=</span> dictCreate(<span style=color:#f92672>&amp;</span>keyptrDictType,NULL);
        server.db[j].expires_cursor <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        server.db[j].blocking_keys <span style=color:#f92672>=</span> dictCreate(<span style=color:#f92672>&amp;</span>keylistDictType,NULL);
        server.db[j].ready_keys <span style=color:#f92672>=</span> dictCreate(<span style=color:#f92672>&amp;</span>objectKeyPointerValueDictType,NULL);
        server.db[j].watched_keys <span style=color:#f92672>=</span> dictCreate(<span style=color:#f92672>&amp;</span>keylistDictType,NULL);
        server.db[j].id <span style=color:#f92672>=</span> j;
        server.db[j].avg_ttl <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        server.db[j].defrag_later <span style=color:#f92672>=</span> listCreate();
        listSetFreeMethod(server.db[j].defrag_later,(<span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>)(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>))sdsfree);
    }
		...
		<span style=color:#66d9ef>if</span> (aeCreateTimeEvent(server.el, <span style=color:#ae81ff>1</span>, serverCron, NULL, NULL) <span style=color:#f92672>==</span> AE_ERR) {
        serverPanic(<span style=color:#e6db74>&#34;Can&#39;t create event loop timers.&#34;</span>);
        exit(<span style=color:#ae81ff>1</span>);
    }

		<span style=color:#75715e>/* Create an event handler for accepting new connections in TCP and Unix
</span><span style=color:#75715e>     * domain sockets. */</span> <span style=color:#75715e>// 对于监听的socket创建对应的文件事件。
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> server.ipfd_count; j<span style=color:#f92672>++</span>) {
        <span style=color:#66d9ef>if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,
            acceptTcpHandler,NULL) <span style=color:#f92672>==</span> AE_ERR)
            {
                serverPanic(
                    <span style=color:#e6db74>&#34;Unrecoverable error creating server.ipfd file event.&#34;</span>);
            }
    }
		...
		aeMain(server.el); <span style=color:#75715e>// 事件处理器的主循环
</span><span style=color:#75715e></span>	}  
}
</code></pre></div><p><strong>命令在接收后阶段的执行过程</strong></p><ul><li><p>命令解析(通信协议, RESP)</p><blockquote><p>redis 协议: <code>\\r\\n</code>(CRLF)区分命令请求的若干参数， <code>*n</code> 表示n个参数, <code>$n</code> 表示参数字符串长度。 如 <code>SET KEY VALUE</code> ，转换协议后为： <code>*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nKEY\\r\\n$5\\r\\nVALUE\\r\\n</code> 特点：</p></blockquote><ul><li>易于实现</li><li>可以高效地被计算机分析（数据的长度放在数据正文)</li><li>可以很容易地被人类读懂 (非二进制)</li></ul></li><li><p>命令调用</p></li><li><p>返回结果</p></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>connSetReadHandler(conn, readQueryFromClient); <span style=color:#75715e>// -&gt; 绑定命令处理器
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>readQueryFromClient</span>(connection <span style=color:#f92672>*</span>conn) {
		<span style=color:#75715e>// 缓冲区一堆操作...
</span><span style=color:#75715e></span>		
		<span style=color:#75715e>// 从查询缓存读取内容，创建参数，并执行命令
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>void</span> processInputBuffer(client <span style=color:#f92672>*</span>c) {
				...
				<span style=color:#75715e>// 判断请求类型   内联命令 和 其他普通
</span><span style=color:#75715e></span>				<span style=color:#75715e>// 将缓冲区中的内容转换成命令，以及命令参数
</span><span style=color:#75715e></span>				<span style=color:#66d9ef>int</span> processMultibulkBuffer(redisClient <span style=color:#f92672>*</span>c) {
					<span style=color:#75715e>// 参数协议解析
</span><span style=color:#75715e></span>				}
				<span style=color:#75715e>// 执行命令
</span><span style=color:#75715e></span>				<span style=color:#66d9ef>int</span> processCommandAndResetClient(client <span style=color:#f92672>*</span>c) {
						<span style=color:#66d9ef>int</span> processCommand(client <span style=color:#f92672>*</span>c) {
								c<span style=color:#f92672>-&gt;</span>cmd <span style=color:#f92672>=</span> c<span style=color:#f92672>-&gt;</span>lastcmd <span style=color:#f92672>=</span> lookupCommand(c<span style=color:#f92672>-&gt;</span>argv[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-&gt;</span>ptr); <span style=color:#75715e>// 查找命令，并进行命令合法性检查，以及命令参数个数检查
</span><span style=color:#75715e></span>
								<span style=color:#75715e>/* Exec the command */</span>
							    <span style=color:#66d9ef>if</span> (c<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> CLIENT_MULTI <span style=color:#f92672>&amp;&amp;</span>
							        c<span style=color:#f92672>-&gt;</span>cmd<span style=color:#f92672>-&gt;</span>proc <span style=color:#f92672>!=</span> execCommand <span style=color:#f92672>&amp;&amp;</span> c<span style=color:#f92672>-&gt;</span>cmd<span style=color:#f92672>-&gt;</span>proc <span style=color:#f92672>!=</span> discardCommand <span style=color:#f92672>&amp;&amp;</span>
							        c<span style=color:#f92672>-&gt;</span>cmd<span style=color:#f92672>-&gt;</span>proc <span style=color:#f92672>!=</span> multiCommand <span style=color:#f92672>&amp;&amp;</span> c<span style=color:#f92672>-&gt;</span>cmd<span style=color:#f92672>-&gt;</span>proc <span style=color:#f92672>!=</span> watchCommand)
							    {
							        queueMultiCommand(c);   <span style=color:#75715e>// 事务命令处理
</span><span style=color:#75715e></span>							        addReply(c,shared.queued);
							    } <span style=color:#66d9ef>else</span> {
							         <span style=color:#75715e>// 执行命令
</span><span style=color:#75715e></span>											<span style=color:#66d9ef>void</span> call(client <span style=color:#f92672>*</span>c, <span style=color:#66d9ef>int</span> flags) {
										    c<span style=color:#f92672>-&gt;</span>cmd<span style=color:#f92672>-&gt;</span>proc(c);   <span style=color:#75715e>// 执行实现函数
</span><span style=color:#75715e></span>											}
							        c<span style=color:#f92672>-&gt;</span>woff <span style=color:#f92672>=</span> server.master_repl_offset;
							        <span style=color:#66d9ef>if</span> (listLength(server.ready_keys))
							            handleClientsBlockedOnKeys();
							    }
						}
				}
		}

}
</code></pre></div><h2 id=事件>事件<a hidden class=anchor aria-hidden=true href=#事件>#</a></h2><p>Redis 是 事件驱动程序 ，有两类事件</p><ul><li><p>文件事件</p><p>套接字与客户端连接，Server和Client通信，产生相应的文件事件，服务器通过监听处理这些事件来完成通信操作</p></li><li><p>时间事件</p><p>服务器中维护的一些操作，在给定时间点执行，抽象为时间事件。如清理过期键值对、持久化、同步等等。</p></li></ul><h3 id=事件的调度执行>事件的调度执行<a hidden class=anchor aria-hidden=true href=#事件的调度执行>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// 事件处理器的主循环
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>aeMain</span>(aeEventLoop <span style=color:#f92672>*</span>eventLoop) {

    eventLoop<span style=color:#f92672>-&gt;</span>stop <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>eventLoop<span style=color:#f92672>-&gt;</span>stop) {

        <span style=color:#75715e>// 如果有需要在事件处理前执行的函数，那么运行它
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (eventLoop<span style=color:#f92672>-&gt;</span>beforesleep <span style=color:#f92672>!=</span> NULL)
            eventLoop<span style=color:#f92672>-&gt;</span>beforesleep(eventLoop);

        <span style=color:#75715e>// 开始处理事件
</span><span style=color:#75715e></span>        aeProcessEvents(eventLoop, AE_ALL_EVENTS);
    }
}

<span style=color:#75715e>// 处理所有已到达的时间事件，以及所有已就绪的文件事件。
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>aeProcessEvents</span>(aeEventLoop <span style=color:#f92672>*</span>eventLoop, <span style=color:#66d9ef>int</span> flags){
	<span style=color:#75715e>// 计算最快要执行的时间事件的等待时间
</span><span style=color:#75715e></span>	aeSearchNearestTimer(eventLoop);
	<span style=color:#75715e>// 阻塞等待文件事件
</span><span style=color:#75715e></span>	aeApiPoll(eventLoop, tvp);
	<span style=color:#75715e>// 处理文件事件
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> (j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> numevents; j<span style=color:#f92672>++</span>) {
    <span style=color:#75715e>// 读事件
</span><span style=color:#75715e></span>    fe<span style=color:#f92672>-&gt;</span>rfileProc(eventLoop,fd,fe<span style=color:#f92672>-&gt;</span>clientData,mask);            
	  <span style=color:#75715e>// 写事件
</span><span style=color:#75715e></span>    fe<span style=color:#f92672>-&gt;</span>wfileProc(eventLoop,fd,fe<span style=color:#f92672>-&gt;</span>clientData,mask);
		processed<span style=color:#f92672>++</span>;
        
	}
	<span style=color:#75715e>// 处理时间事件
</span><span style=color:#75715e></span>	processTimeEvents(aeEventLoop <span style=color:#f92672>*</span>eventLoop)
}
</code></pre></div><h3 id=文件事件>文件事件<a hidden class=anchor aria-hidden=true href=#文件事件>#</a></h3><p><img loading=lazy src=https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f7fba0eb-8679-4098-95c2-f912b8fbe5ea/Untitled.png alt=https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f7fba0eb-8679-4098-95c2-f912b8fbe5ea/Untitled.png></p><ul><li>I/O 多路复用监听套接字，根据套接字的任务不同，分配不同的任务处理器</li><li>当套接字准备好执行操作时，与操作相应的文件事件就会产生，调用关联好的事件处理器</li></ul><p>多种文件处理器：</p><ul><li>连接应答处理器 <code>acceptTcpHandler</code></li><li>命令请求处理器 <code>readQueryFromClient</code></li><li>命令回复处理器 <code>sendReplyToClient</code></li></ul><p>命令在文件事件阶段的执行过程</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// 客户端申请连接，socket 将产生 `AE_READABLE` 类型事件，交给连接处理器处理
</span><span style=color:#75715e></span>aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE, acceptTcpHandler,NULL) <span style=color:#f92672>==</span> AE_ERR)
<span style=color:#75715e>// 客户端发送命令请求，产生一个 `AE_READABLE` 类型事件，交给命令请求处理器...
</span><span style=color:#75715e></span>aeCreateFileEvent(server.el,fd,AE_READABLE, readQueryFromClient, c) <span style=color:#f92672>==</span> AE_ERR
<span style=color:#75715e>// 客户端尝试读取回复，产生一个 `AE_WRITEABLE` 类型事件，交给回复处理器...
</span></code></pre></div><h3 id=时间事件>时间事件<a hidden class=anchor aria-hidden=true href=#时间事件>#</a></h3><ul><li>定时事件</li><li>周期事件</li></ul><p><strong>serverCron 函数</strong></p><ul><li>更新服务器信息，时间、内存</li><li>过期</li><li>持久化</li><li>同步</li></ul><h3 id=线程模型的进化>线程模型的进化<a hidden class=anchor aria-hidden=true href=#线程模型的进化>#</a></h3><p><strong>单线程</strong></p><p><img loading=lazy src=https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ce2276e1-c449-4081-9512-c26c1569d787/Untitled.png alt=https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ce2276e1-c449-4081-9512-c26c1569d787/Untitled.png></p><p>单线程模型的好处</p><ul><li>方便维护、开发、调试</li><li>使用单线程模型也能并发的处理客户端的请求，I/O多路复用</li><li>大多数操作在内存中完成，性能瓶颈不在CPU，在于网络I/O</li></ul><p><strong>不仅仅单线程</strong></p><p>redis 在4.0 版本引入一些支持异步处理的删除命令， <code>UNLINK</code> <code>FLUSHDB ASYNC</code> &mldr;</p><p>对于超大键值对，Redis 可能会需要在释放内存空间上消耗较多的时间，这些操作就会阻塞待处理的任务</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>unlinkCommand</span>(client <span style=color:#f92672>*</span>c) {
   <span style=color:#75715e>/* This command implements DEL and LAZYDEL. */</span>
	<span style=color:#66d9ef>void</span> delGenericCommand(client <span style=color:#f92672>*</span>c, <span style=color:#66d9ef>int</span> lazy) {
	    <span style=color:#66d9ef>int</span> numdel <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, j;
	
	    <span style=color:#66d9ef>for</span> (j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> c<span style=color:#f92672>-&gt;</span>argc; j<span style=color:#f92672>++</span>) {
	        expireIfNeeded(c<span style=color:#f92672>-&gt;</span>db,c<span style=color:#f92672>-&gt;</span>argv[j]);
	        <span style=color:#66d9ef>int</span> deleted  <span style=color:#f92672>=</span> lazy <span style=color:#f92672>?</span> dbAsyncDelete(c<span style=color:#f92672>-&gt;</span>db,c<span style=color:#f92672>-&gt;</span>argv[j]) <span style=color:#f92672>:</span>
	                              dbSyncDelete(c<span style=color:#f92672>-&gt;</span>db,c<span style=color:#f92672>-&gt;</span>argv[j]);
	        <span style=color:#66d9ef>if</span> (deleted) {
	            signalModifiedKey(c,c<span style=color:#f92672>-&gt;</span>db,c<span style=color:#f92672>-&gt;</span>argv[j]);
	            notifyKeyspaceEvent(NOTIFY_GENERIC,
	                <span style=color:#e6db74>&#34;del&#34;</span>,c<span style=color:#f92672>-&gt;</span>argv[j],c<span style=color:#f92672>-&gt;</span>db<span style=color:#f92672>-&gt;</span>id);
	            server.dirty<span style=color:#f92672>++</span>;
	            numdel<span style=color:#f92672>++</span>;
	        }
	    }
	    addReplyLongLong(c,numdel);
	}
}
</code></pre></div><p><strong>网络IO处理多线程</strong></p><blockquote><p>I/O 多路复用的主要作用是让我们可以使用一个线程来监控多个连接是否可读或者可写，但是从网络另一头发的数据包需要先解序列化成 Redis 内部其他模块可以理解的命令，这个过程就是 Redis 6.0 引入多线程来并发处理的。 I/O 多路复用模块收到数据包之后将其丢给后面多个 I/O 线程进行解析，I/O 线程处理结束后，主线程会负责串行的执行这些命令，由于向客户端发回数据包的过程也是比较耗时的，所以执行之后的结果也会交给多个 I/O 线程发送回客户端。</p></blockquote><p><img loading=lazy src=https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5dda5268-afa7-4607-8d18-306f71db15fa/Untitled.png alt=https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5dda5268-afa7-4607-8d18-306f71db15fa/Untitled.png></p><p>实现了I/O读写的多线程，而执行命令依旧是单线程。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>// 在多线程I/O开启时，将读事件放入队列中，等待主线程将读事件分配给I/O线程
</span><span style=color:#75715e>// 这里只是把读事件添加到clients_pending_read队列中而已
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>postponeClientRead</span>(client <span style=color:#f92672>*</span>c) {}

<span style=color:#75715e>// 执行
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>handleClientsWithPendingReadsUsingThreads</span>(<span style=color:#66d9ef>void</span>) {
	<span style=color:#75715e>// 将读事件根据RR，分配给所有的I/O线程（包括主线程自己）
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>while</span>((ln <span style=color:#f92672>=</span> listNext(<span style=color:#f92672>&amp;</span>li))) {
        client <span style=color:#f92672>*</span>c <span style=color:#f92672>=</span> listNodeValue(ln);
        <span style=color:#66d9ef>int</span> target_id <span style=color:#f92672>=</span> item_id <span style=color:#f92672>%</span> server.io_threads_num;
        listAddNodeTail(io_threads_list[target_id],c);
        item_id<span style=color:#f92672>++</span>;
    }
	<span style=color:#75715e>// 主线程读取并解析客户端请求（和I/O线程一起，但不执行命令）
</span><span style=color:#75715e></span>	listRewind(io_threads_list[<span style=color:#ae81ff>0</span>],<span style=color:#f92672>&amp;</span>li);
    <span style=color:#66d9ef>while</span>((ln <span style=color:#f92672>=</span> listNext(<span style=color:#f92672>&amp;</span>li))) {
        client <span style=color:#f92672>*</span>c <span style=color:#f92672>=</span> listNodeValue(ln);
        <span style=color:#75715e>// 这里对应3.1.a中postponeClientRead会返回0, 所以数据会被读取和解析
</span><span style=color:#75715e></span>        readQueryFromClient(c<span style=color:#f92672>-&gt;</span>conn);
    }
	<span style=color:#75715e>// 等待I/O线程读取完毕
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>while</span>(<span style=color:#ae81ff>1</span>) {
        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> pending <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> server.io_threads_num; j<span style=color:#f92672>++</span>)
            pending <span style=color:#f92672>+=</span> io_threads_pending[j];
        <span style=color:#66d9ef>if</span> (pending <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>break</span>;
    }
	<span style=color:#75715e>// 遍历所有的事件（通过遍历clients_pending_read上的客户端），解析和执行命令
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span>(listLength(server.clients_pending_read)) {
        ln <span style=color:#f92672>=</span> listFirst(server.clients_pending_read);
        client <span style=color:#f92672>*</span>c <span style=color:#f92672>=</span> listNodeValue(ln);
        c<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>CLIENT_PENDING_READ;
        listDelNode(server.clients_pending_read,ln);

        <span style=color:#66d9ef>if</span> (c<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> CLIENT_PENDING_COMMAND) {
            <span style=color:#75715e>// b) 若CLIENT_PENDING_COMMAND被标记，说明有命令被解析出来
</span><span style=color:#75715e></span>            <span style=color:#75715e>// 所以要执行命令
</span><span style=color:#75715e></span>            c<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>CLIENT_PENDING_COMMAND;
            <span style=color:#66d9ef>if</span> (processCommandAndResetClient(c) <span style=color:#f92672>==</span> C_ERR) {
                <span style=color:#75715e>/* If the client is no longer valid, we avoid
</span><span style=color:#75715e>                 * processing the client later. So we just go
</span><span style=color:#75715e>                 * to the next. */</span>
                <span style=color:#66d9ef>continue</span>;
            }
        }
        <span style=color:#75715e>// c) 命令解析和执行
</span><span style=color:#75715e></span>        processInputBufferAndReplicate(c);
    }
}
</code></pre></div><p>I/O线程的任务</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>IOThreadMain</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>myid) {
	<span style=color:#75715e>// 轮询，判断是否有任务要做
</span><span style=color:#75715e></span>	<span style=color:#75715e>// 根据任务类型（读/写），执行任务
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>long</span> id <span style=color:#f92672>=</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)myid;
    <span style=color:#66d9ef>while</span>(<span style=color:#ae81ff>1</span>) {
        <span style=color:#75715e>// 轮询，判断是否有任务过来
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1000000</span>; j<span style=color:#f92672>++</span>) {
            <span style=color:#66d9ef>if</span> (io_threads_pending[id] <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>break</span>;
        }
		<span style=color:#75715e>// 遍历任务列表，根据任务类型，执行I/O任务
</span><span style=color:#75715e></span>        listIter li;
        listNode <span style=color:#f92672>*</span>ln;
        listRewind(io_threads_list[id],<span style=color:#f92672>&amp;</span>li);
        <span style=color:#66d9ef>while</span>((ln <span style=color:#f92672>=</span> listNext(<span style=color:#f92672>&amp;</span>li))) {
            client <span style=color:#f92672>*</span>c <span style=color:#f92672>=</span> listNodeValue(ln);
            <span style=color:#66d9ef>if</span> (io_threads_op <span style=color:#f92672>==</span> IO_THREADS_OP_WRITE) {
                writeToClient(c,<span style=color:#ae81ff>0</span>); <span style=color:#75715e>// 写，返回响应
</span><span style=color:#75715e></span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (io_threads_op <span style=color:#f92672>==</span> IO_THREADS_OP_READ) {
                readQueryFromClient(c<span style=color:#f92672>-&gt;</span>conn); <span style=color:#75715e>// 读, 上面提过，不会执行命令
</span><span style=color:#75715e></span>            } <span style=color:#66d9ef>else</span> {
                serverPanic(<span style=color:#e6db74>&#34;io_threads_op value is unknown&#34;</span>);
            }
        }
        <span style=color:#75715e>// 清空任务列表，并设置未完成任务数为0
</span><span style=color:#75715e></span>        listEmpty(io_threads_list[id]);
        io_threads_pending[id] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    }
}
</code></pre></div><h2 id=todo>Todo<a hidden class=anchor aria-hidden=true href=#todo>#</a></h2><ul><li>持久化 - -</li><li>事务 - -</li></ul><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><p><a href=http://redisdoc.com/topic/protocol.html>通信协议（protocol） - Redis 命令参考</a></p><p><a href=https://draveness.me/whys-the-design-redis-single-thread/>为什么 Redis 选择单线程模型 - 面向信仰编程</a></p><p><a href=https://draveness.me/redis-eventloop/>Redis 中的事件循环 - 面向信仰编程</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://chown.xyz/tags/redis/>redis</a></li></ul><nav class=paginav><a class=prev href=http://chown.xyz/posts/fsnotify/><span class=title>« Prev Page</span><br><span>跨平台文件系统监控工具 — fsnotify</span></a>
<a class=next href=http://chown.xyz/posts/go-image/><span class=title>Next Page »</span><br><span>Golang 图片处理 — image 库</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Redis设计与实现之「单机数据库的一些功能实现」 on twitter" href="https://twitter.com/intent/tweet/?text=Redis%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0%e4%b9%8b%e3%80%8c%e5%8d%95%e6%9c%ba%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e4%b8%80%e4%ba%9b%e5%8a%9f%e8%83%bd%e5%ae%9e%e7%8e%b0%e3%80%8d&url=http%3a%2f%2fchown.xyz%2fposts%2fredis-two%2f&hashtags=redis"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Redis设计与实现之「单机数据库的一些功能实现」 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fchown.xyz%2fposts%2fredis-two%2f&title=Redis%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0%e4%b9%8b%e3%80%8c%e5%8d%95%e6%9c%ba%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e4%b8%80%e4%ba%9b%e5%8a%9f%e8%83%bd%e5%ae%9e%e7%8e%b0%e3%80%8d&summary=Redis%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0%e4%b9%8b%e3%80%8c%e5%8d%95%e6%9c%ba%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e4%b8%80%e4%ba%9b%e5%8a%9f%e8%83%bd%e5%ae%9e%e7%8e%b0%e3%80%8d&source=http%3a%2f%2fchown.xyz%2fposts%2fredis-two%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Redis设计与实现之「单机数据库的一些功能实现」 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fchown.xyz%2fposts%2fredis-two%2f&title=Redis%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0%e4%b9%8b%e3%80%8c%e5%8d%95%e6%9c%ba%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e4%b8%80%e4%ba%9b%e5%8a%9f%e8%83%bd%e5%ae%9e%e7%8e%b0%e3%80%8d"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Redis设计与实现之「单机数据库的一些功能实现」 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fchown.xyz%2fposts%2fredis-two%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Redis设计与实现之「单机数据库的一些功能实现」 on whatsapp" href="https://api.whatsapp.com/send?text=Redis%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0%e4%b9%8b%e3%80%8c%e5%8d%95%e6%9c%ba%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e4%b8%80%e4%ba%9b%e5%8a%9f%e8%83%bd%e5%ae%9e%e7%8e%b0%e3%80%8d%20-%20http%3a%2f%2fchown.xyz%2fposts%2fredis-two%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Redis设计与实现之「单机数据库的一些功能实现」 on telegram" href="https://telegram.me/share/url?text=Redis%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0%e4%b9%8b%e3%80%8c%e5%8d%95%e6%9c%ba%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e4%b8%80%e4%ba%9b%e5%8a%9f%e8%83%bd%e5%ae%9e%e7%8e%b0%e3%80%8d&url=http%3a%2f%2fchown.xyz%2fposts%2fredis-two%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2021 <a href=http://chown.xyz>Bazinga's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>